title: JAVA内存模型-线程私有
tag: JVM
---
本篇为学习JAVA虚拟机的第五篇文章，JVM的内存模型一般是面试必问的点，因为对JVM内存模型有所了解，才会有可能知道调优手段。本篇文章首先介绍线程私有的一些区域。
<!-- more -->

## 一、从整体看JVM运行时内存模型

![image](http://bloghello.oursnail.cn/jvm5-1.png)

下面详细说说各个部分的作用。

## 二、内存模型--程序计数器

- **占用内存小**：是一块较小的内存空间，当前线程所执行的字节码的行号指示器。

- **PC作用**：字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

- **线程独立**：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们成这类内存区域为“线程私有”的内存。

- **native方法**：如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空(undefined).

- **无内存溢出异常**：此内存区域是唯一一个在java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

## 三、内存模型--JAVA虚拟机栈

![image](http://bloghello.oursnail.cn/jvm5-2.png)

- 线程私有，生命周期与线程相同。

- 虚拟机栈描述的是Java方法的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

## 四、栈帧

![image](http://bloghello.oursnail.cn/jvm5-3.png)

- 我们口中常常提到的栈与堆，其中栈就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

- 局部变量表存放了编译期可知的各种基本数据类型(`boolean`,`byte`,`char`,`short`,`int`,`float`,`long`,`double`),对象引用(它不等同于对象本身，可能是一个指向对象地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)、`returnAddress`类型(指向了一条字节码指令的地址)

- 其中64位长度的`long`和`double`类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。

- 局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

- 如果线程请求的栈深度大于虚拟机所允许的深度，比如递归层数过多，将抛出`StackOverflowError`异常；如果虚拟机可以动态扩展，即虚拟机栈申请过多，扩展时却无法申请到足够的内存，就会抛出`OutOfMemoryError`异常。

## 五、内存模型--本地方法栈

- 本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈尾虚拟机执行java方法(也就是字节码)服务，而本地方法栈则为虚拟机用到的Native方法服务。

- `Sun HotSpot`虚拟机直接将本地方法栈和虚拟机栈合二为一。

- 与虚拟机栈一样会抛出`StackOverflowError`异常或者`OutOfMemoryError`异常。

**什么是native方法？**

简单地讲，一个`Native Method`就是一个java调用非java代码的接口。一个`Native Method`是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在`C＋＋`中，你可以用`extern “C”`告知`C＋＋`编译器去调用一个C的函数。

下一篇来看看线程共享的区域。